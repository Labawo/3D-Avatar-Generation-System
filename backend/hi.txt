import { useEffect, useState, useRef } from 'react';
import * as Three from 'three'; // Import Three.js
import useAxios from '../utils/useAxios';

const Project = () => {
    const [res, setRes] = useState('');
    const [posRes, setPostRes] = useState('');
    const [projectName, setProjectName] = useState(''); // State to hold project name
    const api = useAxios();
    const canvasRef = useRef(null);
    const textureRef = useRef(null);
    const [texture, setTexture] = useState(null);
    const [selectedFile, setSelectedFile] = useState(null); // New state to hold the selected file
    const sphereRotation = useRef({ x: 0, y: 0 });
    const isDragging = useRef(false);

    useEffect(() => {
        const scene = new Three.Scene();
        const camera = new Three.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
    
        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current });
        renderer.setSize(650, 650);
    
        // Enable shadow rendering in the renderer
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = Three.PCFSoftShadowMap; // Optional: soft shadows
    
        const geometry = new Three.SphereGeometry(1, 32, 32); // Sphere geometry
    
        // Use MeshStandardMaterial to enable shadows
        const material = new Three.MeshStandardMaterial({
            map: texture,
            side: Three.DoubleSide,
        });
    
        const sphere = new Three.Mesh(geometry, material); // Create a sphere
    
        // Enable shadow casting and receiving
        sphere.castShadow = true;
        sphere.receiveShadow = true;
    
        scene.add(sphere);

        const coneGeometry = new Three.ConeGeometry(0.8, 1, 32); // Cone geometry
        const coneMaterial = new Three.MeshStandardMaterial({ color: 0xff0000 }); // Red material for visibility

        const cone = new Three.Mesh(coneGeometry, coneMaterial);
        // Position the cone so that it touches the bottom of the sphere
        const coneInitialPosition = new Three.Vector3(0, -1.05, 0); // Initial cone position relative to sphere center
        cone.position.copy(coneInitialPosition);

        scene.add(cone); // Add the cone to the scene
    
        camera.position.z = 5;
    
        const handleMouseDown = () => {
            isDragging.current = true;
        };
    
        const handleMouseMove = (event) => {
            if (!isDragging.current) return;
    
            sphereRotation.current.x += event.movementY * 0.01;
            sphereRotation.current.y += event.movementX * 0.01;
    
            sphere.rotation.x = sphereRotation.current.x;
            sphere.rotation.y = sphereRotation.current.y;

            const conePosition = coneInitialPosition.clone();
            conePosition.applyAxisAngle(new Three.Vector3(0, 1, 0), sphereRotation.current.y);
            conePosition.applyAxisAngle(new Three.Vector3(1, 0, 0), sphereRotation.current.x);
            cone.position.copy(conePosition);

            cone.rotation.x = sphere.rotation.x;
            cone.rotation.y = sphere.rotation.y;
        };
    
        const handleMouseUp = () => {
            isDragging.current = false;
        };
    
        const cleanup = () => {
            if (canvasRef.current) {
                canvasRef.current.removeEventListener('mousedown', handleMouseDown);
            }
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    
        if (canvasRef.current) {
            canvasRef.current.addEventListener('mousedown', handleMouseDown);
        }
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    
        const animate = () => {
            if (!isDragging.current) {
                // sphere.rotation.x += 0.01;
                sphere.rotation.y += 0.01;
            }
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        };
    
        animate();
    
        // Light setup for casting shadows
        const light = new Three.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 10);
        light.castShadow = true;
    
        scene.add(light);
    
        // Set up shadow properties for the light
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 500;
    
        return cleanup;
    }, [texture]);
    

    const handleImageUpload = (e) => {
        e.preventDefault();
        const file = e.target.files[0];

        if (file) {
            setSelectedFile(file); // Set the selected file to the state
            const reader = new FileReader();
            reader.onload = function (event) {
                const newTexture = new Three.TextureLoader().load(event.target.result, () => {
                    console.log('Image loaded successfully.');
                }, undefined, (err) => {
                    console.error('Error loading image:', err);
                });

                setTexture(newTexture);
            };

            reader.readAsDataURL(file);
        }
    };

    const handleSubmit = async (e) => {
        const formData = new FormData();
        formData.append('name', projectName);
        formData.append('image', selectedFile);
        e.preventDefault();
        try {
            const response = await api.post('/projects/', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data',
                },
            });
    
            // Assuming the response contains image data, handle it accordingly
            const imageData = response?.data?.image; // Extract image data from the response
            if (imageData) {
                // Render the image URL or other relevant information
                setRes(`Upload successfulÄ„`);
            }
            // ... other handling for different response data if needed
        } catch (error) {
            console.error('Error:', error);
            setPostRes('Failed to fetch image data');
        }
    };

    return (
        <section>
            <h1>3D Project</h1>
            <p>{res}</p>
            <input
                type="file"
                accept="image/*"
                onChange={handleImageUpload}
            />
            <canvas
                ref={canvasRef}
                style={{ width: '100%', height: '100%', display: 'block' }}
            ></canvas>
            {/* Form with input field for project name */}
            <form method="POST" onSubmit={handleSubmit}>
                <input
                    type="text"
                    placeholder="Enter Project Name"
                    value={projectName}
                    onChange={(e) => setProjectName(e.target.value)}
                    required // Ensure it's a required field
                />
                <button type="submit">Create Project</button>
            </form>
            {posRes && <p>{posRes}</p>}
            
        </section>
    );
};

export default Project;
